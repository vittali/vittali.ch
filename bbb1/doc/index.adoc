= BBB1: Getting started with the Beagle Bone Black and the PRU via JTAG
:includedir: _includes
:imagesdir: ./images
:icons: font
:toc:
:nofooter:
:BBB: https://beagleboard.org/black[BBB]
:SRM: https://github.com/beagleboard/beaglebone-black/wiki/System-Reference-Manual[SRM]
:PRU: http://processors.wiki.ti.com/index.php/PRU-ICSS?DCMP=pru&HQS=PRU[PRU]
:PRUCape: http://www.ti.com/tool/PRUCAPE[PRU Cape]
:FTDI: https://www.digikey.de/product-detail/de/ftdi-future-technology-devices-international-ltd/TTL-232R-3V3/768-1015-ND/1836393[USB to Serial cable]
:XDS110: http://www.ti.com/tool/TMDSEMU110-U[XDS110 JTAG Debug Probe]
:XDS200: http://www.ti.com/tool/tmdsemu200-u?keyMatch=debug%20probe%20xds200&tisearch=Search-EN-Everything[XSD200]
:JTAG: https://www.digikey.de/product-detail/de/samtec-inc/FTR-110-03-G-D-06/SAM8790-ND/2651173[JTAG header]
:CCS: http://processors.wiki.ti.com/index.php/Download_CCS[Code Composer Studio 8 for Linux 64bit]
:PSSP: https://git.ti.com/pru-software-support-package/pru-software-support-package/trees/v5.1.0[PRU Software Support Package]

This Getting Started Tutorial is one of several small https://vittali.ch[projects] dedicated to real-time programming on the Beagle Bone Black (BBB). I am interested
in using the BBB as an inexpensive test equipment to apply stimulus to other embedded
systems and to obtain time correlated measurements.
This tutorial has been tested with Linux Mint 18.2 on the development host PC.

The project files can be cloned from this https://github.com/vittali/vittali.ch-gst.bbb1[git repo].


== Introduction

The Beagle Bone Black {BBB}, revC (13/2017), described in detail in the System Reference Manual {SRM}, comes with the Sitara AM3358BZCZ100 processor, a SoC (system on chip) that includes not only a 1-Ghz
Cortex A8 processor but also two independent {PRU}s (Programmable Realtime Unit).
These are independent cores, specifically designed for real-time
requirements. In particular, they allow for deterministic digital I/O operations.

This tutorial shows how to set up the required hard- and software tools to program and debug these PRUs.
There are two fundamentally different ways to do this:

. via Linux installed on the BBB (not covered),
. via JTAG (focus of this tutorial).

The first option doesn't require any additional hardware, other than the USB cable that comes with the BBB.
This option is *not* covered in this tutorial.
The second option resembles traditional embedded system programming. Code Composer Studio 8 (CCS)
is used to program and debug the PRUs on the Sitara processor via a JTAG connection.
This option is more demanding in terms of hardware, but it has the advantage that you can debug
the code on the PRU just like any other embedded system.

While several tutorials are available on this topic, I was unable get a working tool chain without trial and error.
PRU development has advanced very rapidly in recent years: there is now a full featured C/C++ compiler and the software installation part
is really very simple, once you have figured out the requirements.

In order to program and debug a PRU you need the following hardware:

.BOM -required items for JTAG operation
* The BBB itself, you can find a distributor here {BBB}.
* The BBB comes without a {JTAG}. It must be purchased separately and soldered on the bottom side of the BBB.

TIP: Before heating up your solder iron, see the soldering tips below.

* A compatible debug probe. I use the {XDS110} in this tutorial which is currently one of the most economic
 solutions to program and debug a bare metal BBB.
 It comes with the required cables, you do need to purchase additional adapters.

TIP: depending on your budget, you might also want to look at a more
powerful alternative {XDS200}.

In addition, I recommend the following optional items:

.BOM - optional items
* The {PRUCape} is an inexpensive extension board and a great help to get you started. The demo later in this tutorial will make use of it.
* The {FTDI} mentioned in the {SRM}, Fig. 54, can be used to establish a serial communication with the host.
It is not suitable for simultaneous usage with the PRU Cape, because the Cape will render the header on the BBB inaccessible.

WARNING: make sure you get a 3.3 V version to match the voltage on the BBB.

* a standard RS232 serial monitor cable. This can be connected to the UART of the PRU cape (rather than the hidden serial header on the BBB) and
allows for serial communications with the host PC.

The total cost is approximately 200 USD, about half as much if you already own a compatible debug probe.

== Preparing the hardware

Before soldering the fine pitch {JTAG}, you might want to refresh your soldering skills.
As an inspiration, I recommend the video tutorials by https://www.youtube.com/watch?v=5uiroWBkdFY[John Gammel].
Here are some highlights from these videos that I found helpful:

. don't worry about shorts until finished,
. to remove shorts, don't use solder wig, use flux.

WARNING: Be aware that if you test your work with an ohmmeter, you will apply a small voltage to the pins of the Sitara processor.
Strictly speaking, this voids your warranty as explained in the {SRM}. I do not know, though, if this kind of voltage can really damage the chip.

Once you are finished, your hardware setup should look like this ( using the XDS110 Debug Probe ):

.Debug configuration
image::setup.jpg[debug configuration]

And here is a closeup showing the key (missing pin on the JTAG header):

.The JTAG header with the missing pin (key)
image::closeup.jpg[JTAG connector,300,200]

== Preventing Linux from booting

The BBB comes with Linux flashed to the onboard eMMC. To prevent Linux from booting -
remember we don't need and want Linux to run when using the JTAG option -
you must hold the boot switch pressed when applying power.
This switch is not easily accessible with the PRU Cape mounted.
The heartbeat indicator LED will start to flash as soon as the boot process has started.

The are many tutorials available on how not to boot from the eMMC, none of which worked for me.
So I settled for the brute force approach and erased the eMMC.

WARNING: This will completely erase the device mmcblkx, where x depends on your configuration. With no SDCard inserted
x is probably 0. Use `fdisk -l` to discover the available devices.

[listing]
.Erase the boot device - choose _x_ according to your config
$ dd if=/dev/zero of=/dev/mmcblkx bs=2M count=2048

Now, when you apply power, only the power LED should be permanently on.

== Installing the software development environment

Code Composer Studio (CCS) still requires some 32 bit libraries:

[source]
$ sudo apt-get install libc6-i386


* Download {CCS} ( version CCS8.0.0.00016).
* Extract the archive and run the installer ( not as root ):

[source]
$ ./ccs_setup_linux64_8.0.0.00016.bin

In Processor Support select:

* Sitara AMx Processors
* other processors for which you require support

Start CCS.
Verify that the version is CCS8.0.0.00016.

From the CCS App Center, install the *PRU C compiler* option.

Finally, download {PSSP} to a location of your choice. This package is optional and contains code examples.

That's all. You are now ready for your first program on the PRU.

== Using the demo examples from the support package

Before you proceed, these were the most useful resources for me:

. a http://processors.wiki.ti.com/index.php/PRU-ICSS_Debug_on_AM335x[wiki page] dedicated to bare bones PRU programming on the Sitara processor.

. this audio presentation: http://software-dl.ti.com/public/hpmp/sitara/debug_pru_using_ccs/presentation_html5.html[Debug PRU with CCS].

While the presentation does use a different debug probe and a previous version of CCS, it is still relevant, and in my view, the most useful resource for the task at hand.

You are now ready to import a demo from the {PSSP}, for example

`pru-software-support-package-pru-software-support-package/pru_cape/pru_fw/PRU_LED0`

* import the project into CCS and modify the Debug Configuration as shown in the resources 1. and 2.
* click on the `Debug` icon. The debugger will stop at `main`.
* click on `Resume` to see the LEDs blink on the PRU Cape.

If you encounter problems, clone the tutorial repo and compare the contents with your work:

[listing]
$ git clone git@bitbucket.org:pvittali/pvittali.bitbucket.io.git
$ cd bbb1

Import `bb1/PRU_LED0` in your workspace. The repo contains a copy of the {PSSP} (5.1.0) and is therefore self-contained.

== Further Reading

Here are a few more pointers not mentioned in this tutorial:

.Beagle Bone Black (BBB)
- https://elinux.org/Beagleboard:BeagleBoneBlack#BeagleBone_Black_Description[BBB Wiki on elinux.org]. A collection of hardware and software resources, tips and tricks.
- https://www.twosixlabs.com/running-a-baremetal-beaglebone-black-part-1/[Running a Baremetal Beaglebone Black]. Includes a detailed description on how to prepare for JTAG debugging.
- https://blog.parr.us/2014/11/14/beaglebone-black-debugging-via-ti-usb100v2-jtag-emulator/[BeagleBone Black Debugging via TI USB100v2 JTAG Emulator]. Another BBB bare bone setup account.

.Sitara Processor
- https://training.ti.com/sitara-arm-processors-boot-camp-training-series[Sitara™ ARM® Processors Boot Camp Training Series]. A comprehensive list of training material provided by TI.

.PRU
- http://processors.wiki.ti.com/index.php/PRU_Cape_Getting_Started_Guide[PRU Cape Getting started]. A short guide presenting the hardware on the cape.
- http://processors.wiki.ti.com/index.php/PRU_Training:_Hands-on_Labs[Hands-on Labs]. Practical examples on PRU programming.
- http://catch22.eu/beaglebone/beaglebone-pru-c/[PRU C code]. A short and clear introduction to C programming on the PRU.


== Appendix

=== JTAG debugging
include::{includedir}/JTAG.adoc[]
